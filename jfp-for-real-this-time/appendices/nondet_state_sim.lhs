\section{Simulating Nondeterminism with State: The Proofs}
%-------------------------------------------------------------------------------
\subsection{Only State and Nondeterminism}

This section shows that the |runNondet| function is equivalent
to the following nondeterminism handler.

\begin{code}
hNondet :: MNondet m => NondetC a -> m a
hNondet = fold genND algND
  where 
    genND           = return 
    algND Fail      = mzero
    algND (Or p q)  = p `mplus` q
\end{code}
In what follows, we show that this handler is equal to the |runNondet| function
of Section \ref{sec:sim-nondet-state}.
\begin{theorem}
|runNondet = hNondet|
\end{theorem}
\begin{proof}
We start with expanding the definition of |runNondet|:
< extract . simulate = hNondet
Both |simulate| and |hNondet| are written as a fold.
We can use the universal property of fold to show that |runNondet| and
|hNondet| are equal.
Therefore, we will use the fold fusion law for postcomposition as defined in 
Equation \ref{eq:fusion-post}.
We have to prove that
\begin{enumerate}
    \item |extract . gen = genND|
    \item |extract . alg = algND . fmap extract|
\end{enumerate}
The first item is simple to prove with equational reasoning.
<    extract (gen x)
< = {-~  definition of |gen|  -}
<    extract (append x pop)
< = {-~  definition of |extract|  -}
<    fst . snd $ runState (runST (append x pop)) (mzero, [])
< = {-~  evaluation of |append|  -}
<    fst . snd $ runState (runST pop) (mzero `mplus` return x, [])
< = {-~  identity of |mzero| (\ref{eq:mzero})  -}
<    fst . snd $ runState (runST pop) (return x, [])
< = {-~  evaluation of |runST pop|, |runState|  -}
<    fst . snd $ ((), (return x, []))
< = {-~  evaluation of |fst|, |snd|  -}
<    return x
< = {-~  definition of |genND|  -}
<    genND x
The property that |extract . gen = return| is called 
\emph{extract-gen}\label{eq:extract-gen}.
For the second item that we have to prove, we do a case analysis.

\fbox{|Fail|}

<    extract (alg Fail)
< = {-~  definition of |alg|  -}
<    extract pop
< = {-~  definition of |extract|  -}
<    fst . snd $ runState (runST pop) (mzero, [])
< = {-~  evaluation of |runST pop|, |runState|  -}
<    fst . snd $ ((), (mzero, []))
< = {-~  evaluation of |fst|, |snd|  -}
<    mzero
< = {-~  definition of |algND|  -}
<    algND Fail
< = {-~  definition of |fmap|  -}
<    (algND . fmap extract) Fail
The property that |extract (alg Fail) = mzero| is called 
\emph{extract-alg-1}\label{eq:extract-alg-1}.

\fbox{|Or p q|}

<    extract (alg (Or p q))
< = {-~  definition of |alg|  -}
<    extract (push q p)
< = {-~  definition of |extract|  -}
<    fst . snd $ runState (runST (push q p)) (mzero, [])
< = {-~  evaluation of |push q p|  -}
<    fst . snd $ runState (runST p) (mzero, [q])
< = {-~  property pop-extract for |p|  -}
<    fst . snd $ runState (runST pop) (mzero `mplus` extract p, [q])
< = {-~  identity of |mzero| (\ref{eq:mzero})  -}
<    fst . snd $ runState (runST pop) (extract p, [q])
< = {-~  evaluation of |pop|  -}
<    fst . snd $ runState (runST q) (extract p, [])
< = {-~  property pop-extract for |q|  -}
<    fst . snd $ runState (runST pop) (extract p `mplus` extract q, [])
< = {-~  evaluation of |runST pop|, |runState|  -}
<    fst . snd $ ((), (extract p `mplus` extract q, []))
< = {-~  evaluation of |fst|, |snd|.  -}
<    extract p `mplus` extract q
< = {-~  definition of |algND|  -}
<    algND (Or (extract p) (extract q))
< = {-~  definition of |fmap|  -}
<    (algND . fmap extract) (Or p q)
The property that |extract (alg (Or p q)) = extract p `mplus` extract q| 
is called \emph{extract-alg-2}\label{eq:extract-alg-2}.
\end{proof}

In this proof we have used the property pop-extract, which states the following: 
\begin{theorem}[pop-extract]
<    runState  (runST p)    (q, stack) 
< =  runState  (runST pop)  (q `mplus` extract p, stack)
\end{theorem}
We call this property the pop-extract property.
The key element to have this property is to 
only utilize a subset of terms with type |ST m a|, namely those
that are generated by the fold of the |simulate| function,
so for which this property is true.
Indeed, we only generate such terms.
To prove this, we need to show that 
(1) the generator of |simulate| only generates programs of this subset;
and (2) the algebra preserves this property.

\begin{theorem}[pop-extract part 1]
<   runState (runST (gen x)) (q, stack) = runState (runST pop) (q `mplus` extract (gen x), stack)
\end{theorem}
We use equational reasoning to prove this theorem.
\begin{proof}
<    runState (runST (gen x)) (q, stack)
< = {-~  definition of |gen|  -}
<    runState (runST (append x pop)) (q, stack)
< = {-~  evaluation of |append|  -}
<    runState (runST pop) (q `mplus` return x, stack)
< = {-~  property extract-gen (\ref{eq:extract-gen})  -}
<    runState (runST pop) (q `mplus` extract (gen x), stack)
\end{proof}

\begin{theorem}[pop-extract part 2]
<     runState  (runST (alg x))  (q, stack) 
< =   runState  (runST pop)      (q `mplus` extract (alg x), stack)
\end{theorem}
\begin{proof}
We use equational reasoning with case analysis on |x|.

\fbox{|Fail|}

<    runState (runST (alg Fail)) (q, stack)
< = {-~  definition of |alg|  -}
<    runState (runST pop) (q, stack)
< = {-~  identity of |mzero| (\ref{eq:mzero})  -}
<    runState (runST pop) (q `mplus` mzero, stack)
< = {-~  property extract-alg-1 (\ref{eq:extract-alg-1})  -}
<    runState (runST pop) (q `mplus` extract (alg Fail), stack)

\fbox{|Or p1 p2|}
Assume that |p1| and |p2| satisfy this theorem.

<    runState (runST (alg (Or p1 p2))) (q, stack)
< = {-~  definition of |alg|  -}
<    runState (runST (push p2 p1)) (q, stack)
< = {-~  evaluation of |push p2 p1|  -}
<    runState (runST p1) (q, p2:stack)
< = {-~  induction: property of |p1|  -}
<    runState (runST pop) (q `mplus` extract p1, p2:stack)
< = {-~  evaluation of |pop|  -}
<    runState (runST p2) (q `mplus` extract p1, stack)
< = {-~  induction: property of |p2|  -}
<    runState (runST pop) (q `mplus` extract p1 `mplus` extract p2, stack)
< = {-~  property extract-alg-2 (\ref{eq:extract-alg-2})  -}
<    runState (runST pop) (q `mplus` extract (alg (Or p1 p2)), stack)
Note that the above two proofs are mutually recursive. However, only the 
pop-extract proof uses induction. As we work inductively on (smaller) subterms,
the proofs do work out. 
\end{proof}

%-------------------------------------------------------------------------------
\subsection{In Combination with Other Effects}

This section shows that |runNondet'| is equivalent to 
the following nondeterminism handler.

< hNondet' :: (Functor f, MNondet m) => Free (NondetF :+: f) a -> Free f (m a)
< hNondet' = fold gen alg 
<   where 
<     genND' = Var . return 
<     algND' (Inl Fail)      = Var mzero
<     algND' (Inl (Or p q))  = mplus <$> p <*> q
<     algND' (Inr y)         = Op y
We prove that this handler |hNondet'| is equal to the |runNondet'| function of
Section \ref{sec:combining-the-simulation-with-other-effects}.
\begin{theorem}
|runNondet' = hNondet'|
\end{theorem}
As before, we first expand the definition of |runNondet'|, 
which is written in terms of |simulate'|, a fold. 
We use fold fusion to incorporate |extract'| in the fold of |simulate'|.
The universal property of fold then teaches us that |runNondet'| and
|hNondet'| are equal.
More concretely, we have to prove the following two things:
\begin{enumerate}
    \item |extract' . gen' = genND'|
    \item |extract' . alg' = algND' . fmap extract'|
\end{enumerate}
\begin{proof}
For the first item we use simple equational reasoning techniques.
<    extract' (gen' x)
< = {-~  definition of |gen'|  -}
<    extract' (append' x pop')
< = {-~  definition of |extract'|  -}
<    fst . snd <$> runStateT (unST (append' x pop')) (mzero, [])
< = {-~  evaluation of |append'|  -}
<    fst . snd <$> runStateT (unST pop') (mzero `mplus` return x, [])
< = {-~  identity of |mzero| (\ref{eq:mzero})  -}
<    fst . snd <$> runStateT (unST pop') (return x, [])
< = {-~  evaluation of |unST pop'|, |runStateT|  -}
<    fst . snd <$> Var ((), (return x, []))
< = {-~  evaluation of |fst|, |snd|  -}
<    Var (return x)
< = {-~  definition of |genND'|  -}
<    genND' x

For the second item that we have to prove, we do a case analysis.

\fbox{|Inl Fail|}

<    extract' (alg' (Inl Fail))
< = {-~  definition of |alg'|  -}
<    extract' pop'
< = {-~  definition of |extract'|  -}
<    fst . snd <$> runStateT (unST pop') (mzero, [])
< = {-~  evaluation of |unST pop'|, |runStateT|  -}
<    fst . snd <$> Var ((), (mzero, []))
< = {-~  evaluation of |fst|, |snd|  -}
<    Var mzero
< = {-~  definition of |algND'|  -}
<    algND' (Inl Fail)
< = {-~  definition of |fmap|  -}
<    (algND' . fmap extract') (Inl Fail)

\fbox{|Inl (Or p q)|}

<    extract' (alg' (Inl (Or p q)))
< = {-~  definition of |alg'|  -}
<    extract' (push' q p)
< = {-~  definition of |extract'|  -}
<    fst . snd <$> runStateT (unST (push' q p)) (mzero, [])
< = {-~  evaluation of |push' q p|  -}
<    fst . snd <$> runStateT (unST p) (mzero, [q])
< = {-~  property pop-extract for |p|  -}
<    fst . snd <$> runStateT (unST pop') (mzero `mplus` extract' p, [q])
< = {-~  identity of |mzero| (\ref{eq:mzero})  -}
<    fst . snd <$> runStateT (unST pop') (extract' p, [q])
< = {-~  evaluation of |pop'|  -}
<    fst . snd <$> runStateT (unST q) (extract' p, []) 
< = {-~  property pop-extract for |q|  -}
<    fst . snd <$> runStateT (unST pop') (extract' p `mplus` extract' q, []) 
< = {-~  evaluation of |unST pop'|, |runStateT|  -}
<    fst . snd <$> Var ((), (extract' p `mplus` extract' q, []))
< = {-~  evaluation of |fst|, |snd|  -}
<    Var (extract' p `mplus` extract' q)
< = {-~  definition of |liftA2|  -}
<    mplus <$> extract' p <*> extract' q
< = {-~  definition of |algND'|  -}
<    algND' (Inl (Or (extract' p) (extract' q)))
< = {-~  definition of |fmap|  -}
<    (algND' . fmap extract') (Inl (Or p q))

\fbox{|Inr y|}

<    extract' (alg' (Inr y))
< = {-~  definition of |alg'|  -}
<    extract' (ST' $ join $ lift $ Op (return . unST <$> y))
< = {-~  definition of |extract'|  -}
<    fst . snd <$> runStateT (unST (ST' $ join $ lift $ Op (return . unST <$> y))) (mzero, [])
< = {-~  |unST . ST' = id|  -}
<    fst . snd <$> runStateT (join $ lift $ Op (return . unST <$> y)) (mzero, [])
< = {-~  definition of |join| for |StateT|  -}
<    fst . snd <$> runStateT 
<        (StateT $ \ s -> runStateT (lift $ Op (return . unST <$> y)) s >>= \(x', s') -> runStateT x' s') 
<        (mzero, [])
< = {-~  |runStateT . StateT = id|  -}
<    fst . snd <$> 
<        (\ s -> runStateT (lift $ Op (return . unST <$> y)) s >>= \ (x', s') -> runStateT x' s') 
<        (mzero, [])
< = {-~  definition of |lift|  -}
<    fst . snd <$> 
<        (\ s -> runStateT (StateT $ \ s -> Op (return . unST <$> y) 
<             >>= \ x -> return (x, s)) s 
<             >>= \ (x', s') -> runStateT x' s') 
<        (mzero, [])
< = {-~  |runStateT . StateT = id|  -}
<    fst . snd <$> 
<        (\ s -> (\ s -> Op (return . unST <$> y) 
<             >>= \ x -> return (x, s)) s 
<             >>= \ (x', s') -> runStateT x' s') 
<        (mzero, [])
< = {-~  application  -}
<    fst . snd <$> 
<        (\ s -> Op (return . unST <$> y) 
<             >>= \ x -> return (x, s) 
<             >>= \ (x', s') -> runStateT x' s') 
<        (mzero, [])
< = {-~  simplification  -}
<    fst . snd <$> 
<        (\ s -> Op (return . unST <$> y) >>= \ x -> runStateT x s) 
<        (mzero, [])
< = {-~  application  -}
<    fst . snd <$> (Op (return . unST <$> y) >>= \ x -> runStateT x (mzero, []))
< = {-~  simplification  -}
<    fst . snd <$> Op (fmap (>>= \ x -> runStateT x (mzero, [])) (fmap (return . unST) y))
< = {-~  functor law: composition of |fmap| (\ref{eq:functor-composition}) -}
<    fst . snd <$> Op (fmap ((>>= \ x -> runStateT x (mzero, [])) . return . unST) y)
< = {-~  monad law return-bind (\ref{eq:monad-ret-bind}) -}
<    fst . snd <$> Op (fmap ((\ x -> runStateT x (mzero, [])) . unST) y)
< = {-~  simplification -}
<    fst . snd <$> Op (fmap (\ x -> runStateT (unST x) (mzero, [])) y)
< = {-~  definition of |fmap| -}
<    Op (fst $ snd $ fmap (\ x -> runStateT (unST x) (mzero, [])) y)




\todo{stuck}



<    Op (fst . snd <$> runStateT (unST y) (mzero, []))
< = {-~  definition of |extract'|  -}
<    Op (extract' y)
< = {-~  definition of |algND'|  -}
<    algND' (Inr (extract' y))
< = {-~  definition of |fmap|  -}
<    (algND' . fmap extract') (Inr y)
\end{proof}