We are grateful for your helpful comments, and are especially gladdened your
appreciation:

  * "extremely well-written"
  * "going significantly beyond [...] previous work"
  * "exemplary in its precision and rigor"
  * "I enjoyed reading this paper"
  * ...

We will do our best to address all comments in the final version, but focus
here only on the main ones.


# Review B:

## About Dom not having a bind:

There are two key ideas that make the emulation of local state by means
of global state work:

  1. We impose a discipline that all uses of put are state-restoring;
     no `wild' puts are allowed.

     => Without a bind, a disciplined Dom value cannot be extended in a
        sequential (i.e., bind-) fashion with a wild put.

  2. The state at the end of a branch is transferred to (the beginning of)
     the next branch.

     => Without a bind, we know where a branch is at its end and where to transfer
        the state to the next branch. With a bind, we would not know when we are at the
        end of the branch and would have to defer the transfer, allowing for the
        possibility that an entirely different state value is passed to the next
        branch.

We will articulate this better, incorporating your suggestion about moving the concrete Dom
from the appendix to the main text. 


# Review C:

## Background

Given the extensive body of work on programming and reasoning with monads, we
believe it is justified to rely on some background from the reader.
Nevertheless, we hear your request to improve the accessibility by explaining
concepts like hylomorphisms and scanl in more detail.

## (Algebraic) Effect Handlers Approach:

> "in the middle of the paper it is revealed that the reader should have read
>  the paper interpreting certain things as syntax and certain as semantics. In
>  addition the meaning (semantics) of = is described in vague terms informally in
>  a cryptic note reference to event handlers"

This is not what we intended. On the contrary, like the "Just do It" paper, we
advocate high-level axiomatic reasoning based on algebraic laws to understand
programs. However, as an auxiliary proof device, briefly sketched on p.8, and
elaborated in more detail in Sections 6-7 (and in our Coq mechanisation), we
can reason about monadic programs by separating their syntax and semantics.
Specific notions of equality are given on lines 942 and 979.

## Implications of a Domain without Bind

There are no implications, and that's precisely the point. The local state
axioms act like an interface based on which we can reason, and which decouples
the reasoning from any particular implementation. Sections 6-7 show that the
global state domain provides a valid implementation of the 'interface'.
The beauty of having reasoned against the interface is that we can use the
implementation without having to revisit any of the earlier proofs.

## (Non-)Modularity / Encapsulation:

There is modularity and non-modularity at different levels, which should not
be mixed up.

 - As explained above, the axioms decouple the reasoning from a particular
   implementation and thus provide modularity.

 -  As we require a particular interaction between state and non-determinism,
    namely the local state semantics, by definition we do not want to reason about
    them in isolation.

 -  Satisfying the local state axioms by means of global state, requires a
    global discipline of only state-restoring updates.
    We carry out this proof once for all disciplined global state programs.
    The proof is then encapsulated in the local state axioms, so that
    anyone can reason a locally about the equivalence of specific programs
    based on those axioms.

## Novelty wrt "Just do It":

In a personal communication, Jeremy Gibbons, "Just do It" author, states the
novelty as follows:

> The Just Do It paper deals only with the backtrackable combination of
> nondeterminism and state, where composition distributes rightwards over failure
> (ie failure is a right zero of composition) and over choice - your laws
> (15,16). We don’t deal with persistent state, your law (18). We didn’t know
> then what the right axiomatization was for persistent state, nor a suitable
> model for it - we confidently asserted (S7) that s->([a],s) is an alternative
> model of nondeterminism and state, but in fact I believe this is not even a
> monad. Your paper contributes a useful axiomatization, experimental validation
> of those axioms through a variant of N Queens that doesn’t copy the state, a
> model, and a Coq verification of that model.


# Review D:

> It seems that the contributions of this paper (lines 43-51) lie in justifying
> these techniques by equational reasoning on monadic programs. I find these
> contributions relatively thin, because rather than deriving theorems from a set
> of standalone equational laws, the paper freely drops down to the level of
> free-monad syntax trees (lines 368-381).

We feel that this does not do justice to our contributions:

- The "Novelty wrt "Just do It"" paragraph above enumerates a range of novelties
  compared to the earlier work.

- Proving the correctness of global state with respect to local state has not
  been a triviality, but a substantial effort, not just to find the appropriate
  auxiliary lemmas, but to create the appropriate proof approach.

- We are not aware of any prior proof for this problem, mechanised or
  otherwise, for the monadic setting (or any other) that supports
  axiomatic reasoning about program equivalence. In the absence of any other
  approach that has been demonstrated to solve the problem, we do not understand
  what fault you see in our approach.

- We believe that our approach is highly relevant because it can be used for 
  similar problems when reasoning about algebraic effects and handlers (see Local
  Algebraic Theories in Related Work), which are becoming increasingly more
  prominent and where programmers are writing algebras for free-monad syntax
  trees all the time.


> I have serious doubts about the first side condition on line 491, proven on line 543.

That is indeed a mistake -- we inadvertently copied an earlier, wrong
version of the lemma into the text. Lemma 5.2 should come with a
side-condition: m commutes with state, while the "n" in Theorem 5.1 should be
unfoldM p f z. In our particular application, unfoldM p f = perm, which does
satisfy the side conditions because non-determinism is its only effect. We have
included the correct theorems and their proofs in attachment.
